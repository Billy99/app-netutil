// SPDX-License-Identifier: Apache-2.0
// Copyright(c) 2019 Red Hat, Inc.

//
// This module reads and parses any configuration data provided
// to a container by the host. This module manages the
// file operations and the mapping between the data format
// of the provided configuration data and the data format used
// by app-netutil.
//
// Currently, configuration data can be passed to the container
// thru Environmental Variables, Annotations, or shared files.
//

package apputil

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/golang/glog"
	"github.com/containernetworking/cni/pkg/types"
	"github.com/containernetworking/cni/pkg/types/current"
)


// NOTE: Should the Userspace Keys be pulled from Userspace CNI?
//       Need Userspace PR pushed before this could be done.
const (
	filePathAnnotation = "/etc/podinfo/annotations"
	filePathLabel = "/etc/podinfo/labels"
	annotKeyNetworkStatus = "k8s.v1.cni.cncf.io/networks-status"
	annotKeyUsrspConfigData = "userspace-cni/configuration-data"
	annotKeyUsrspMappedDir = "userspace-cni/mapped-dir"
)

//
// Types
//

// Multus Types
type NetworkStatus struct {
	Name       string    `json:"name,omitempty"`
	Interface  string    `json:"interface,omitempty"`
	IPs        []string  `json:"ips,omitempty"`
	Mac        string    `json:"mac,omitempty"`
}

type MultusNetworkStatus struct {
	Name       string    `json:"name"`
	Interface  string    `json:"interface,omitempty"`
	IPs        []string  `json:"ips,omitempty"`
	Mac        string    `json:"mac,omitempty"`
	Default    bool      `json:"default,omitempty"`
	DNS        types.DNS `json:"dns,omitempty"`
}

// Userspace CNI Types
type MemifConf struct {
	Role        string  `json:"role,omitempty"`   // Role of memif: master|slave
	Mode        string  `json:"mode,omitempty"`   // Mode of memif: ip|ethernet|inject-punt

	// Autogenerated as memif-<ContainerID[:12]>-<IfName>.sock i.e. memif-0958c8871b32-net1.sock
	// Filename only, no path. Will use if populated, but used to passed filename to container.
	Socketfile  string  `json:"socketfile,omitempty"`
}

type VhostConf struct {
	Mode        string  `json:"mode,omitempty"`   // vhost-user mode: client|server

	// Autogenerated as <ContainerID[:12]>-<IfName> i.e. 0958c8871b32-net1
	// Filename only, no path. Will use if populated, but used to passed filename to container.
	Socketfile  string  `json:"socketfile,omitempty"`
}

type BridgeConf struct {
	// ovs-dpdk specific note:
	//   ovs-dpdk requires a bridge to create an interfaces. So if 'NetType' is set
	//   to something other than 'bridge', a bridge is still need and this field will
	//   be inspected. For ovs-dpdk, if bridge data is not populated, it will default
	//   to 'br-0'. 
	BridgeName string `json:"bridgeName,omitempty"` // Bridge Name
	BridgeId   int    `json:"bridgeId,omitempty"`   // Bridge Id - Deprecated in favor of BridgeName
	VlanId     int    `json:"vlanId,omitempty"`     // Optional VLAN Id
}

type UserSpaceConf struct {
	// The Container Instance will default to the Host Instance value if a given attribute
	// is not provided. However, they are not required to be the same and a Container
	// attribute can be provided to override. All values are listed as 'omitempty' to
	// allow the Container struct to be empty where desired.
	Engine     string     `json:"engine,omitempty"`  // CNI Implementation {vpp|ovs-dpdk}
	IfType     string     `json:"iftype,omitempty"`  // Type of interface {memif|vhostuser}
	NetType    string     `json:"netType,omitempty"` // Interface network type {none|bridge|interface}
	MemifConf  MemifConf  `json:"memif,omitempty"`
	VhostConf  VhostConf  `json:"vhost,omitempty"`
	BridgeConf BridgeConf `json:"bridge,omitempty"`
}

type ConfigurationData struct {
	ContainerId   string          `json:"containerId"` // From args.ContainerId, used locally. Used in several place, namely in the socket filenames.
	IfName        string          `json:"ifName"`      // From args.IfName, used locally. Used in several place, namely in the socket filenames.
	Name          string          `json:"name"`        // From NetConf.Name
	Config        UserSpaceConf   `json:"config"`      // From NetConf.ContainerConf
	IPResult      current.Result  `json:"ipResult"`    // Network Status also has IP, but wrong format
}

//
// API Functions
//
func GetInterfaces(intType string) (*InterfaceResponse, error) {
	glog.Infof("GetInterfaces: ENTER")

	if intType == "" {
		return nil, fmt.Errorf("GetInterfaces: Interface type '' not implemented")
	}

	// Retrieve the basic data from annotations
	response, err := retrieveInterfaces()
	if err != nil {
		glog.Errorf("GetInterfaces: Error calling RetrieveInterfaces: %v", err)
		return nil, err
	}

	// Process SR-IOV Interfaces
	if intType == INTERFACE_TYPE_SRIOV || intType == INTERFACE_TYPE_ALL {
	}

	if intType == INTERFACE_TYPE_VHOST || intType == INTERFACE_TYPE_MEMIF || intType == INTERFACE_TYPE_ALL {
	}

	return response, nil
}

//
// Local Functions
//
func retrieveInterfaces() (*InterfaceResponse, error) {
	response := &InterfaceResponse{}

	// Open Annotations File
	glog.Infof("RetrieveInterfaces: Open %s", filePathAnnotation)
	file, err := os.Open(filePathAnnotation)
	if err != nil {
		glog.Errorf("RetrieveInterfaces: Error opening \"annotations\" file: %v", err)
		return response, err
	}
	defer file.Close()

	// Buffers to store unmarshalled annotations used by app-netutil
	networkStatusSlice := []MultusNetworkStatus{}
	usrspConfigDataSlice := []ConfigurationData{}
	var usrspMappedDir string

	//
	// Parse the file into individual annotations
	//
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		status := strings.Split(string(line), "\n")

		// Loop through each annotation
		for _, s := range status {
			glog.Infof("  s-%v", s)
			parts := strings.Split(string(s), "=")

			// DEBUG
			glog.Infof("  PartsLen-%d", len(parts))
			if len(parts) >= 1 {
				glog.Infof("  parts[0]-%s", parts[0])
			}

			if len(parts) == 2 {

				// Remove the Indent from the original marshalling
				parts[1] = strings.Replace(string(parts[1]), "\\n", "", -1)
				parts[1] = strings.Replace(string(parts[1]), "\\", "", -1)
				parts[1] = strings.Replace(string(parts[1]), " ", "", -1)
				parts[1] = string(parts[1][1:len(parts[1])-1])

				// Parse the Network Status added by Multus CNI
				if parts[0] == annotKeyNetworkStatus {
					if err = json.Unmarshal([]byte(parts[1]), &networkStatusSlice); err != nil {
						glog.Errorf("Error unmarshal \"%s\": %v", annotKeyNetworkStatus, err)
						return nil, err
					}
				}

				// Parse the Configuration Data added by Userspace CNI
				if parts[0] == annotKeyUsrspConfigData {
					if err = json.Unmarshal([]byte(parts[1]), &usrspConfigDataSlice); err != nil {
						glog.Errorf("Error unmarshal \"%s\": %v", annotKeyUsrspConfigData, err)
					}
				}

				// Parse the Mapped Directory added by Userspace CNI
				if parts[0] == annotKeyUsrspMappedDir {
					usrspMappedDir = string([]byte(parts[1]))
				}
			}
		}
	}

	// Network Status should always exist and provides the number of
	// interfaces. The remaining data is optional (provided based on
	// interface type) and will be filled in if provided.
	glog.Infof("PRINT EACH NetworkStatus - len=%d", len(networkStatusSlice))
	if len(networkStatusSlice) != 0 {
		for _, status := range networkStatusSlice {
			glog.Infof("  status:")
			glog.Infof("%v", status)

			response.Interface = append(response.Interface, &InterfaceData{
					IfName: status.Interface,
					Name: status.Name,
					Type: INTERFACE_TYPE_UNKNOWN,
					Network: &NetworkData{
						IPs: status.IPs,
						Default: status.Default,
						DNS: status.DNS,
					},
				})
		}
	} else {
		err = fmt.Errorf("Error: \"%s\" annotation not available but required", annotKeyNetworkStatus)
		return nil, err
	}

	glog.Infof("PRINT EACH Userspace MappedDir")
	glog.Infof("  usrspMappedDir:")
	glog.Infof("%v", usrspMappedDir)

	glog.Infof("PRINT EACH Userspace ConfigData")
	for _, configData := range usrspConfigDataSlice {
		glog.Infof("  configData:")
		glog.Infof("%v", configData)

		if usrspMappedDir == "" {
			glog.Warningf("Error: \"%s\" annotation not available but required for Userspace interfaces", annotKeyUsrspMappedDir)
		}

		for _, interfaceData := range response.Interface {
			if interfaceData.IfName != "" &&
			   interfaceData.IfName == configData.IfName {

				glog.Infof("  MATCH:")

				if configData.Config.IfType == "vhostuser" {
					interfaceData.Type = INTERFACE_TYPE_VHOST
					interfaceData.Vhost = &VhostData{
						Mode: configData.Config.VhostConf.Mode,
						Socketpath: usrspMappedDir + configData.Config.VhostConf.Socketfile,
					}
				} else if configData.Config.IfType == "memif" {
					interfaceData.Type = INTERFACE_TYPE_MEMIF
					interfaceData.Memif = &MemifData{
						Role: configData.Config.MemifConf.Role,
						Mode: configData.Config.MemifConf.Mode,
						Socketpath: usrspMappedDir + configData.Config.MemifConf.Socketfile,
					}
				} else {
					interfaceData.Type = INTERFACE_TYPE_INVALID
					glog.Warningf("Invalid type found for interface %s", interfaceData.IfName)
				}
			}
		}
	}


	// PCI Address for SR-IOV Interfaces are found in
	// Environmental Variables. Search through them to
	// see if any can be found.
	glog.Infof("PROCESS ENV:")
	envResponse, err := GetEnv()
	if err != nil {
		glog.Errorf("RetrieveInterfaces: Error calling GetEnv: %v", err)
		return nil, err
	}
	pciAddressSlice := []string{}
	for k, v := range envResponse.Envs {
		if strings.HasPrefix(k, "PCIDEVICE") {
			glog.Infof("  k:%v v:%v", k, v)
			valueParts := strings.Split(string(v), ",")
			for _, id := range valueParts {
				glog.Infof("     Adding ID:%v", id)
				pciAddressSlice = append(pciAddressSlice, id)
			}
		}
	}

	var pciIndex int
	for _, interfaceData := range response.Interface {
		if interfaceData.Type == INTERFACE_TYPE_UNKNOWN {
			if interfaceData.Network.Default {
				glog.Infof(" Set Interface to kernel: %s", interfaceData.IfName)
				interfaceData.Type = INTERFACE_TYPE_KERNEL
			} else {
				// TBD: Need a better way to determine if SR_IOV or not.
				glog.Infof(" Set Interface to SR-IOV: %s  PCIIndex=%d Len=%d", interfaceData.IfName, pciIndex, len(pciAddressSlice))
				interfaceData.Type = INTERFACE_TYPE_SRIOV
				if pciIndex < len(pciAddressSlice) {
					interfaceData.Sriov = &SriovData{
						PciAddress: pciAddressSlice[pciIndex],
					}
					pciIndex++
					glog.Infof(" Added PCI Address: %s", interfaceData.Sriov.PciAddress)
				} else {
					glog.Warningf("More SR-IOV interfaces detected than PCI addresses - %s", interfaceData.IfName)
				}
			}
		}
	}

	glog.Infof("RESPONSE:")
	for _, interfaceData := range response.Interface {
		glog.Infof("%v", interfaceData)
	}

	return response, err
}
